{"version":3,"file":"326.b62c2b97.iframe.bundle.js","mappings":";AA2CA;AAyBA;AAKA;AAyDA;ACzGA;AACA;AAGA;;;;AAMA;AAGA","sources":["webpack://superset/./src/filters/components/Range/RangeFilterPlugin.tsx","webpack://superset/./src/filters/components/common.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  ensureIsArray,\n  getColumnLabel,\n  getNumberFormatter,\n  NumberFormats,\n  styled,\n  t,\n} from '@superset-ui/core';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { rgba } from 'emotion-rgba';\nimport { AntdSlider } from 'src/components';\nimport { FilterBarOrientation } from 'src/dashboard/types';\nimport { PluginFilterRangeProps } from './types';\nimport { StatusMessage, StyledFormItem, FilterPluginStyle } from '../common';\nimport { getRangeExtraFormData } from '../../utils';\nimport { SingleValueType } from './SingleValueType';\n\nconst LIGHT_BLUE = '#99e7f0';\nconst DARK_BLUE = '#6dd3e3';\nconst LIGHT_GRAY = '#f5f5f5';\nconst DARK_GRAY = '#e1e1e1';\n\nconst StyledMinSlider = styled(AntdSlider)<{\n  validateStatus?: 'error' | 'warning' | 'info';\n}>`\n  ${({ theme, validateStatus }) => `\n  .ant-slider-rail {\n    background-color: ${\n      validateStatus ? theme.colors[validateStatus]?.light1 : LIGHT_BLUE\n    };\n  }\n\n  .ant-slider-track {\n    background-color: ${LIGHT_GRAY};\n  }\n\n  &:hover {\n    .ant-slider-rail {\n      background-color: ${\n        validateStatus ? theme.colors[validateStatus]?.base : DARK_BLUE\n      };\n    }\n\n    .ant-slider-track {\n      background-color: ${DARK_GRAY};\n    }\n  }\n  `}\n`;\n\nconst Wrapper = styled.div<{\n  validateStatus?: 'error' | 'warning' | 'info';\n  orientation?: FilterBarOrientation;\n  isOverflowing?: boolean;\n}>`\n  ${({ theme, validateStatus, orientation, isOverflowing }) => `\n    border: 1px solid transparent;\n    &:focus {\n      border: 1px solid\n        ${theme.colors[validateStatus || 'primary']?.base};\n      outline: 0;\n      box-shadow: 0 0 0 3px\n        ${rgba(theme.colors[validateStatus || 'primary']?.base, 0.2)};\n    }\n    & .ant-slider {\n      margin-top: ${\n        orientation === FilterBarOrientation.HORIZONTAL ? 0 : theme.gridUnit\n      }px;\n      margin-bottom: ${\n        orientation === FilterBarOrientation.HORIZONTAL ? 0 : theme.gridUnit * 5\n      }px;\n\n      ${\n        orientation === FilterBarOrientation.HORIZONTAL &&\n        !isOverflowing &&\n        `line-height: 1.2;`\n      }\n\n      & .ant-slider-track {\n        background-color: ${\n          validateStatus && theme.colors[validateStatus]?.light1\n        };\n      }\n      & .ant-slider-handle {\n        border: ${\n          validateStatus && `2px solid ${theme.colors[validateStatus]?.light1}`\n        };\n        &:focus {\n          box-shadow: 0 0 0 3px\n            ${rgba(theme.colors[validateStatus || 'primary']?.base, 0.2)};\n        }\n      }\n      & .ant-slider-mark {\n        font-size: ${theme.typography.sizes.s}px;\n      }\n\n      &:hover {\n        & .ant-slider-track {\n          background-color: ${\n            validateStatus && theme.colors[validateStatus]?.base\n          };\n        }\n        & .ant-slider-handle {\n          border: ${\n            validateStatus && `2px solid ${theme.colors[validateStatus]?.base}`\n          };\n        }\n      }\n    }\n  `}\n`;\n\nconst numberFormatter = getNumberFormatter(NumberFormats.SMART_NUMBER);\n\nconst tipFormatter = (value: number) => numberFormatter(value);\n\nconst getLabel = (lower: number | null, upper: number | null): string => {\n  if (lower !== null && upper !== null && lower === upper) {\n    return `x = ${numberFormatter(lower)}`;\n  }\n  if (lower !== null && upper !== null) {\n    return `${numberFormatter(lower)} ≤ x ≤ ${numberFormatter(upper)}`;\n  }\n  if (lower !== null) {\n    return `x ≥ ${numberFormatter(lower)}`;\n  }\n  if (upper !== null) {\n    return `x ≤ ${numberFormatter(upper)}`;\n  }\n  return '';\n};\n\nconst getMarks = (\n  lower: number | null,\n  upper: number | null,\n): { [key: number]: string } => {\n  const newMarks: { [key: number]: string } = {};\n  if (lower !== null) {\n    newMarks[lower] = numberFormatter(lower);\n  }\n  if (upper !== null) {\n    newMarks[upper] = numberFormatter(upper);\n  }\n  return newMarks;\n};\n\nexport default function RangeFilterPlugin(props: PluginFilterRangeProps) {\n  const {\n    data,\n    formData,\n    height,\n    width,\n    setDataMask,\n    setFocusedFilter,\n    unsetFocusedFilter,\n    setHoveredFilter,\n    unsetHoveredFilter,\n    setFilterActive,\n    filterState,\n    inputRef,\n    filterBarOrientation,\n    isOverflowingFilterBar,\n  } = props;\n  const [row] = data;\n  // @ts-ignore\n  const { min, max }: { min: number; max: number } = row;\n  const { groupby, defaultValue, enableSingleValue } = formData;\n\n  const enableSingleMinValue = enableSingleValue === SingleValueType.Minimum;\n  const enableSingleMaxValue = enableSingleValue === SingleValueType.Maximum;\n  const enableSingleExactValue = enableSingleValue === SingleValueType.Exact;\n  const rangeValue = enableSingleValue === undefined;\n\n  const [col = ''] = ensureIsArray(groupby).map(getColumnLabel);\n  const [value, setValue] = useState<[number, number]>(\n    defaultValue ?? [min, enableSingleExactValue ? min : max],\n  );\n  const [marks, setMarks] = useState<{ [key: number]: string }>({});\n  const minIndex = 0;\n  const maxIndex = 1;\n  const minMax = value ?? [min, max];\n\n  const getBounds = useCallback(\n    (\n      value: [number, number],\n    ): { lower: number | null; upper: number | null } => {\n      const [lowerRaw, upperRaw] = value;\n\n      if (enableSingleExactValue) {\n        return { lower: lowerRaw, upper: upperRaw };\n      }\n\n      return {\n        lower: lowerRaw > min ? lowerRaw : null,\n        upper: upperRaw < max ? upperRaw : null,\n      };\n    },\n    [max, min, enableSingleExactValue],\n  );\n\n  const handleAfterChange = useCallback(\n    (value: [number, number]): void => {\n      setValue(value);\n      const { lower, upper } = getBounds(value);\n      setMarks(getMarks(lower, upper));\n\n      setDataMask({\n        extraFormData: getRangeExtraFormData(col, lower, upper),\n        filterState: {\n          value: lower !== null || upper !== null ? value : null,\n          label: getLabel(lower, upper),\n        },\n      });\n    },\n    [col, getBounds, setDataMask],\n  );\n\n  const handleChange = useCallback((value: [number, number]) => {\n    setValue(value);\n  }, []);\n\n  useEffect(() => {\n    // when switch filter type and queriesData still not updated we need ignore this case (in FilterBar)\n    if (row?.min === undefined && row?.max === undefined) {\n      return;\n    }\n\n    let filterStateValue = filterState.value ?? [min, max];\n    if (enableSingleMaxValue) {\n      const filterStateMax =\n        filterStateValue[maxIndex] <= minMax[maxIndex]\n          ? filterStateValue[maxIndex]\n          : minMax[maxIndex];\n\n      filterStateValue = [min, filterStateMax];\n    } else if (enableSingleMinValue) {\n      const filterStateMin =\n        filterStateValue[minIndex] >= minMax[minIndex]\n          ? filterStateValue[minIndex]\n          : minMax[minIndex];\n\n      filterStateValue = [filterStateMin, max];\n    } else if (enableSingleExactValue) {\n      filterStateValue = [minMax[minIndex], minMax[minIndex]];\n    }\n\n    handleAfterChange(filterStateValue);\n  }, [\n    enableSingleMaxValue,\n    enableSingleMinValue,\n    enableSingleExactValue,\n    JSON.stringify(filterState.value),\n    JSON.stringify(data),\n  ]);\n\n  const formItemExtra = useMemo(() => {\n    if (filterState.validateMessage) {\n      return (\n        <StatusMessage status={filterState.validateStatus}>\n          {filterState.validateMessage}\n        </StatusMessage>\n      );\n    }\n    return undefined;\n  }, [filterState.validateMessage, filterState.validateStatus]);\n\n  useEffect(() => {\n    if (enableSingleMaxValue) {\n      handleAfterChange([min, minMax[maxIndex]]);\n    }\n  }, [enableSingleMaxValue]);\n\n  useEffect(() => {\n    if (enableSingleMinValue) {\n      handleAfterChange([minMax[minIndex], max]);\n    }\n  }, [enableSingleMinValue]);\n\n  useEffect(() => {\n    if (enableSingleExactValue) {\n      handleAfterChange([minMax[minIndex], minMax[minIndex]]);\n    }\n  }, [enableSingleExactValue]);\n\n  return (\n    <FilterPluginStyle height={height} width={width}>\n      {Number.isNaN(Number(min)) || Number.isNaN(Number(max)) ? (\n        <h4>{t('Chosen non-numeric column')}</h4>\n      ) : (\n        <StyledFormItem extra={formItemExtra}>\n          <Wrapper\n            tabIndex={-1}\n            ref={inputRef}\n            validateStatus={filterState.validateStatus}\n            orientation={filterBarOrientation}\n            isOverflowing={isOverflowingFilterBar}\n            onFocus={setFocusedFilter}\n            onBlur={unsetFocusedFilter}\n            onMouseEnter={setHoveredFilter}\n            onMouseLeave={unsetHoveredFilter}\n            onMouseDown={() => setFilterActive(true)}\n            onMouseUp={() => setFilterActive(false)}\n          >\n            {enableSingleMaxValue && (\n              <AntdSlider\n                min={min}\n                max={max}\n                value={minMax[maxIndex]}\n                tipFormatter={tipFormatter}\n                marks={marks}\n                onAfterChange={value => handleAfterChange([min, value])}\n                onChange={value => handleChange([min, value])}\n              />\n            )}\n            {enableSingleMinValue && (\n              <StyledMinSlider\n                validateStatus={filterState.validateStatus}\n                min={min}\n                max={max}\n                value={minMax[minIndex]}\n                tipFormatter={tipFormatter}\n                marks={marks}\n                onAfterChange={value => handleAfterChange([value, max])}\n                onChange={value => handleChange([value, max])}\n              />\n            )}\n            {enableSingleExactValue && (\n              <AntdSlider\n                min={min}\n                max={max}\n                included={false}\n                value={minMax[minIndex]}\n                tipFormatter={tipFormatter}\n                marks={marks}\n                onAfterChange={value => handleAfterChange([value, value])}\n                onChange={value => handleChange([value, value])}\n              />\n            )}\n            {rangeValue && (\n              <AntdSlider\n                range\n                min={min}\n                max={max}\n                value={minMax}\n                onAfterChange={handleAfterChange}\n                onChange={handleChange}\n                tipFormatter={tipFormatter}\n                marks={marks}\n              />\n            )}\n          </Wrapper>\n        </StyledFormItem>\n      )}\n    </FilterPluginStyle>\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { styled } from '@superset-ui/core';\nimport { PluginFilterStylesProps } from './types';\nimport FormItem from '../../components/Form/FormItem';\n\nexport const RESPONSIVE_WIDTH = 0;\n\nexport const FilterPluginStyle = styled.div<PluginFilterStylesProps>`\n  min-height: ${({ height }) => height}px;\n  width: ${({ width }) => (width === RESPONSIVE_WIDTH ? '100%' : `${width}px`)};\n`;\n\nexport const StyledFormItem = styled(FormItem)`\n  &.ant-row.ant-form-item {\n    margin: 0;\n  }\n`;\n\nexport const StatusMessage = styled.div<{\n  status?: 'error' | 'warning' | 'info';\n}>`\n  color: ${({ theme, status = 'error' }) => theme.colors[status]?.base};\n`;\n"],"names":[],"sourceRoot":""}